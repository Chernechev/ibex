=======================================================================
Webspr 0.1.3.5
=======================================================================

See the end of this README for release notes.


1. Introduction
-----------------------------------------------------------------------
Webspr allows self-paced reading experiments and speeded acceptability
judgment experiments to be conducted online through a web browser.
There are two components: a JavaScript-heavy web page, and a server
written in Python.


2. Setting up the server.
-----------------------------------------------------------------------
There are two ways of running the server: either as a stand-alone
server or as a CGI process. By default, the server runs in stand-alone
mode; to start it, simply execute server.py:

    python server.py

Note that you will need to have the "paste" module installed for
Python in order for stand-alone mode to work (see
http://pythonpaste.org). The CGI mode requires only modules that come
with the standard Python 2.5 distribution.

The stand-alone server is limited to serving the files "spr.html",
"json.js", "main.js", "conf.js", "util.js", "dashed_sentence.js" and
"data.js", and is thus rather inflexible in its current form. However,
it is useful for testing experimental designs without setting up a
full-blown HTTP server.

Input data should be in a file called data.js in the same directory as
spr.html. The server saves results in a file called "results", and
saves the raw POST data it receives in a file called "raw_results".

The server can be configured by editing server_conf.py. Each of the
options is commented. Change the SERVER_MODE variable to determine
whether the server will run in stand-alone mode or as a CGI process.
When SERVER_MODE is set to "cgi", server.py will work as a standard
CGI program; when it is set to "paste", the server will run in
stand-alone mode.  You can change the value of the PORT variable to
determine the port the server will listen on when operating in
stand-alone mode.

The "-m" command line option can be used to set the server mode when
starting the server, overriding the value of SERVER_MODE in
server_conf.py. The "-p" option can be used to set the listening port
of the server when operating in stand-alone mode; this option
overrides the value of PORT in server_conf.py.

In theory, using the software is a simple as running the server by
either of the methods described above, constructing a suitable data.js
file, and pointing your subjects to http://your.server/spr.html.

The server stores some state in a directory called server_state. This
directory is automatically created by the server if it does not
already exist, and in order to start the server from a fresh state,
you may simply delete this directory. (Currently, it only contains the
counter used to alternate latin square designs.)

The server logs messages in the file server.log in the same directory
as server.py. The default is to store all files in the same directory
as server.py, but the working directory of the server can be modified
by setting the environment variable "WEBSPR_WORKING_DIR". You can also
set the variable of the same name in server_conf.py.

On Linux/Unix/OS X, the server uses file locking to ensure that the
results file and server state remain consistent. Currently, it does
not do so on Windows, so there is a theoretical possibility of the
state or the results being corrupted if you run the server in a
Windows environement (but unless you have very high traffic, it's
purely theoretical).

The stand-alone server has been tested on Windows and OS X (but will
almost certainly work on any system with Python 2.5). The CGI server
has been tested on OS X using the lighttpd web server.


3. Example data file
-----------------------------------------------------------------------
This distribution comes with an example data file, example_data.js,
containing a data set for a speeded acceptability judgment task
(thanks to Brian Dillon for the data). You can switch to a self-paced
reading design by changing the value of the 'experimentType' variable
to "self-paced reading". The next section covers the format of data.js
for self-paced reading tasks, and section 6 for speeded acceptability
judgment tasks.


4. Self-paced reading tasks
-----------------------------------------------------------------------
The following is an example data.js for a self-paced reading task:

    __________ BEGIN EXAMPLE data.js __________

    var experimentType = "self-paced reading";

    var instructionsHTML = "<p>[Your instructions go here.]</p>";

    var sentences_strings = [

    [0, "A practice sentence"],
    [0, "A practice sentence with a comprehension question",
        ["What kind of sentence was that?",
         "A practice", "A real sentence"]],

    [[1,1], "A type 1 sentence that has correct agreement"],
    [[2,1], "A type 2 sentence that have incorrect agreement"],

    [[1,2], "Another type 1 sentence that has correct agreement"],
    [[2,2], "Another type 2 sentence that have incorrect agreement",
            ["A comprehension question?",
             "Right answer",
             "First wrong answer",
             "Second wrong answer"]],

    [-1, "This is a filler sentence"],
    [-1, "A boring filler, now with a comprehension question",
         ["Did you understand that?",
          "Yes", "No"]]

    ];

    __________ END EXAMPLE data.js __________

The instructions you give in the 'instructionsHTML' variable will be
displayed when the user first visits the page. The user can press any
key to clear the instructions and move onto the experiment, so
remember to include some kind of "press any key to continue" message
in your instructions.

Each sentence has a type. Types are stored in the results file and
make it easy to group sentences for analysis. Types may be either
strings or integers, and types themselves have no meaning.

In addition to a type, each sentence has a "group" (which also may be
either a string or an integer). This facilitates the implementation of
latin square designs. See the next section for more information on
types and groups, and means of arranging sentences in an appropriate
sequence.

Owing to differences in browsers, screen sizes, etc., it is impossible
to predict whether or not a given sentence will fit onto a single
line. For this reason, the software detects when a line boundary is
crossed and flags this in the results, allowing timings influenced by
line breaks to be excluded from analysis.

Results are saved in CSV format. The columns do not have headings in
the results file. Each set of results is preceded by a header giving
the time, date, browser user agent string and other information. Each
line of the header is preceded by a "#".

IMPORTANT: Each row corresponds to a single instance of a spacebar
pressing by a single participant.

In order, the columns are as follows:

    1. Date
    The date/time at which the server received the results of which
    this line is a part. This is an integer representing seconds since
    January 1 1970 (UNIX/POSIX time).

    2. Sentence
    The number of the sentence (as determined by the order of
    sentences in data.js). Note that sentence hashes can also be used
    to identify sentences (see 10).

    3. Word
    The word number, starting from 1. (I.e. the result for word 1 is
    the time it took to read the first word, or in other words, the
    time it took for the subject to make the second word appear.)

    4. Type
    The type of the sentence, as given in data.js.

    5. Time
    Integer giving the reading time in ms.

    6. Newline
    Indicates whether or not the user went onto a new line to read
    this word (i.e., whether the word is the first word on a new
    line). 1 for yes, 0 for no.

    7. Answer
    Indicates whether or not the comprehension question was answered
    correctly. 1 for yes, 0 for no.

    8. Length
    The length of the word in characters.

    9. IP Hash
    MD5 hash of the subject's IP address as a hexadecimal string.

    10. Sentence hash
    MD5 hash of the sentence (with one space between each word --
    multiple spaces, newlines, etc. are trimmed before hashing).

    11. Group
    The sentence's group (this will be "NULL" if the sentence has no
    group).
    (This is last in order to maintain backwards compatibility with
    earlier versions of the software which did not implement groups.)

The following variables may be defined in data.js to alter the default
parameters of the task and to configure other options:

    var serverURI              (default = "server.py")
        STRING
        The URI for the server (used when results are sent to the
        server). Keep this in sync with (a) the name of .py file
        containing the server code and (b) the value of PY_SCRIPT_NAME
        in server_conf.py. It is unlikely that you want to change
        this, and the default should Just Work.

    var instructionsHTML       (default: see above)
        STRING
        See above in this section.

    var completionMessage      (default: basic success message)
        STRING
        The message displayed when the results have successfully been
        sent to the server.

    var completionErrorMessage (default: basic error message)
        STRING
        The message displayed if there was an error sending the
        results to the server.

    var practiceSentenceType   (default = 0)
    	STRING/INT
        The type associated with practice sentences. Webspr flags
    	practice sentences so that participants know they are not
    	reading a "real" sentence. In speeded acceptability judgment
    	tasks, there is also the option to give participants more time
    	for practice sentences (see section 6).

    var shuffleSequence        (default: see section 5)
        OBJECT
        See section 5.

    var pageTitle              (default = "Experiment")
        STRING
	Changes the title of the webpage.

    var showProgressBar        (default = true)
    	BOOLEAN
	Whether or not to display a progress bar indicating how far
        the participant has progressed through the set of sentences.

The following variable only applies to self-paced reading experiments:

    var flagWrongAnswers      (default = true)
        BOOLEAN
	Whether or not to tell participants when they have answered a
        comprehension question incorrectly.


5. Types, groups and the order of sentences.
-----------------------------------------------------------------------
Webspr is able to automate simple "latin square" designs, and
randomize the order of "real" and filler sentences in such a way that
fillers are evenly spaced. This feature depends on the assignment of
sentences to "types" and "groups". Groups are relevant to latin
squares: each participant is presented with one sentence from each
group over the course of the task. Types are used for randomizing the
order of sentences after sentences have been picked out of groups.
To recap, types and groups are assigned using the following syntax:

    [[TYPE, GROUP], "Sentence string...", ...]

GROUP can be set to null if the sentence is not in a group of similar
sentences (this is equivalent to assigning the sentence to its own
unique group). Both types and groups may either be strings or integers
(or, as mentioned, null in the case of groups). An alternative to
explicitly specifying a null group is to use the following format
with an implicit null group:

    [TYPE, "Sentence string", ...]

Webspr has a rather involved method of ordering sentences that is
designed to be highly customizable. The method used has the following
two major steps:

    1. Pick a single sentence from each group (i.e. implement a latin
       square design).

    2. Execute a "shuffle sequence" specified by the user in order to
       determine the final ordering of sentences.

The first step is straightforward. The server maintains a counter
which is used to rotate latin square designs, such that every design
is run an equal number of times (or as close as possible to an equal
number of times). The counter depends on the participant having
cookies enabled in his browser; if he does not, a random choice of
design is made.

Moving on to the second major step, a "shuffle sequence" is a
JavaScript data structure describing a series of "shuffling",
randomizing and sequencing operations over an array of sentences.
There are three basic operations, 'seq', 'randomize' and
'shuffle'. Both take a series of "type predicates" as arguments, where
each type predicate is the characteristic function of a set of
sentence types. A type predicate may be any of the following:

    * A string or integer, denoting the characteristic function of all
      sentences of the given type.

    * A list of strings/integers, denoting the characteristic function
      of all sentences belonging to any one of the types in the list.

    * A JavaScript function, returning a boolean value when given a
      type (either a string or integer).

The basic operations work as follows:

    * A statement of the form seq(pred1, pred2, pred3, ...) specifies
      a sequence where all sentences matching pred1 precede all
      sentences matching pred2, all sentences matching pred2 precede
      all sentences matching pred3, and so on. The original relative
      ordering between sentences of the same type is preserved. A
      'seq' with only one argument is permissible.

    * A statement of the form randomize(pred1) specifies a randomly
      ordered sequence of all sentences matching pred1.

    * A statement of the form shuffle(pred1, pred2, pred3, ...)
      specifies that sentences matching the given predicates should be
      shuffled together in such a way that sentences matching each
      predicate are evenly spaced. The original relative ordering
      between sentences of the same type is preserved.

The following type predicates are predefined as JavaScript functions:

    anyType       // Matches any type.
    lessThan0     // Matches any integer type < 0.
    greaterThan0  // Matches any integer type > 0.
    equalTo0      // Matches any integer type == 0.
    startsWith(s) // Matches any string type starting with s.
    endsWith(s)   // Matches any string type ending with s.
    not(pred)     // Matches anything that is not of a type matched
                  // by pred.

If you define your own predicates, be careful to test that they are
cross-browser compatible. See section 7 for some pertinent advice.
The predicates above are defined in shuffle.js.

The power of shuffle sequences derives from the possibility of
composing them without limit. Suppose we want the following order:
all practice sentences in their original order followed by evenly
spaced real and filler sentences in random order. Assuming the types
"practice", "real" and "filler", we could use the following shuffle
sequence:

    seq("practice", shuffle(randomize("real"), randomize("filler")))

Now suppose that there are two types of real sentence ("real1" and
"real2"), and we wish to order the sentences the same way as before:

    seq("practice", shuffle(randomize(["real1", "real2"]),
                    randomize("filler")))

What if we also want the two types of real sentence to be evenly
spaced?  The following formula will do the trick:

    seq("practice", shuffle(randomize("filler"),
                            shuffle(randomize("real1"),
                                    randomize("real2"))))

This first shuffles sentences of type "real1" and sentences of type
"real2" and then shuffles filler sentences into the mix.  Finally,
practice sentences are prepended in the order they were given in
data.js.

Since it is often useful to apply 'randomize' to every argument of
'shuffle', there is a utility function, 'rshuffle', which automates
this. The following equivalence holds:

    rshuffle(a1, a2, ...) = shuffle(randomize(a1), randomize(a2), ...)

If no shuffle sequence is specified, Webspr uses the following default
sequence:

    seq(equalTo0, rshuffle(greaterThan0, lessThan0))

This will seem rather cryptic to anyone not familiar with the behavior
of earlier versions of Webspr, where this ordering specification was
built in and unchangeable. In short, it works well if practice
sentences have type 0, filler sentences have integer types < 0, and
real sentences have integer types > 0.

IMPORTANT: A shuffle sequence must always have one of 'seq',
'shuffle', 'randomize' or 'rshuffle' as its outer element. A single
string or integer is NOT a valid shuffle sequence, and neither is
not("foo"). Thus, one must use seq("foo"), not just "foo", and
seq(not("foo")), not just not("foo").

Note that it is possible to include duplicate sentences in the final
sequence. For example, seq("foo", "foo") would include every sentence
of type "foo" twice. For this reason, it is possible to accidentally
include duplicate sentences if a number of your predicates overlap.

You can define your own shuffle sequence operators quite easily; see
shuffle.js for the definitions of the 'seq', 'shuffle' and 'randomize'
operators.


6. Speeded acceptability judgment tasks.
-----------------------------------------------------------------------
This section describes the differences between a data.js for a
self-paced reading task and a data.js for a speeded acceptability
judgment task; it will therefore not make much sense unless you've
read section 4. You should also read section 8 for important
information on how speeded acceptability tasks run on different
browsers.

The most important difference is that the value of 'experimentType'
must be changed to "speeded acceptability".

The list of sentences has exactly the same format as for a self-paced
reading experiment. However, any comprehension questions will be
ignored. There are some additional variables which can be defined in
data.js in order to modify the default parameters for the task:

    var wordTime                  (default = 300)
        INTEGER
        The time in ms for which each word is displayed.

    var wordPauseTime             (default = 100)
        INTEGER
        The time in ms for which each word is blanked before the next
        word is shown.

    var acceptabilityRatingsPreamble
        STRING
        Example: "How would you rate this sentence on a scale of 1-5?"

    var acceptabilityRatings      (default=[["Good","f"], ["Bad","j"]])
        ARRAY OF STRING/[STRING,STRING]
        If an array of strings, specifies the ratings which a user may
        choose from. The user may press the first character of each
        rating to select it. A [STRING,STRING] pair may be used
        instead of a simple string; in this case, the second string
        must contain a single character, specifying the key the user
        should press to select the rating.

    var judgmentTimeFrame         (default = 3)
        INTEGER
        The time in seconds a participant has to make an acceptability
        judgment on a "real" or filler sentence. If this is set to 0
        or null, no time limit is imposed on participants.

    var practiceJudgmentTimeFrame (default = 3)
        INTEGER
        As above, but applies to practice sentences only. Note that it
        is not possible for only one of judgmentTimeFrame and
        practiceJudgmentTimeFrame to be 0 or null.

    var showCounter               (default = false)
        BOOLEAN
        Whether or not to display a counter showing the participant
        how much time he has left to give a judgment.

The value of the variable 'flagWrongAnswers' is ignored, since speeded
acceptability judgment tasks cannot have comprehension questions.

The format of the results file is quite different compared to that for
self-paced reading experiments. There is one line per sentence, and
each line has the following columns:

    1. Time
    As for self-paced reading results.

    2. Sentence number
    As for self-paced reading results.

    3. Sentence type
    As for self-paced reading results.

    4. Line breaks A list of the form "(n1-n2-n3...)" (i.e. a
    hyphen-separated list of integers enclosed in parentheses), giving
    a list of the numbers of the words which were the last word on a
    line.

    5. Rating
    The rating the user gave the sentence. The special value "TIMEOUT"
    is used if the user did not give the sentence a rating within the
    time limit.

    6. IP hash
    MD5 hash of the participant's IP address, as for self-paced
    reading results.

    7. Sentence hash
    MD5 hash of the sentence, as for self-paced reading results.

    8. Group The sentence's group (this will be "NULL" if the sentence
    has no group).


7. Common gotchas
-----------------------------------------------------------------------
The following are some subtle problems which can often arise when
writing data.js:

    * A missing comma in the list of sentences in data.js can cause
      highly obscure JavaScript errors with no obvious relation to
      their source.

    * Some browsers accept trailing commas in JavaScript array
      literals (i.e. they accept [1,2,3,4,] as a fine array); others
      do not. If your browser of choice accepts array literals of this
      form, be sure to check that your data.js has no trailing commas
      so that there will be no browser incompatibilities.

Setting the value of the 'instructionsHTML' configuration option can
also be a bit of a pain, since writing HTML code inside JavaScript
string literals is a bit finicky. Remember to escape singe/double
quotes with a "\" (depending on whether you enclose the string in
single/double quotes) and to escape newlines with a "\" also (by
making "\" the last character of the line). Some browsers may accept
JavaScript string literals containing unescaped newlines, but most
will not, so make sure you don't use them.

Most browsers allow strings to be indexed using square brackets
(i.e. "foo"[1] == "f"). Internet Explorer, however, requires the use
of the string's 'charAt' method.


8. Browser compatibility
-----------------------------------------------------------------------
Webspr has been tested on Firefox 3b1/2.0.0.8/1.5.0.7/1.0.7, Safari 3,
Opera 9.24 and Internet Explorer 6/7.

In the case of speeded acceptability judgment tasks, Firefox seems to
run a little faster than other browsers. Of course, JavaScript does
not provide any exact timing mechanisms, and times between words will
be slightly longer than those specified in data.js on all browsers
(simply because it takes additional time to blank/show
words). However, there is still a significant difference between
Firefox and other browsers. The following are times for getting
through a 100 word sentence with wordTime = 300 and
wordPauseTime = 100:

Firefox 2/3b1   41.4 seconds
IE 6            42.8 seconds
Opera           42.8 seconds
Safari 3        42.8 seconds

The results above were consistently obtained over a number of trials.
If you believe that a difference of this size is likely to have a
significant effect on results, you may wish to request that your
subjects do not use Firefox.  Note that the user agent string of each
subject's browser is stored in the header for each set of results.


9. Automatic generation of data.js
-----------------------------------------------------------------------
This distribution includes the Python module convert.py, which may be
useful for writing scripts to generate data.js files automatically.
The module defines classes which allow the contents of a data.js file
to be represented as a Python data structures, and a function for
outputting a data.js file given one of these data structures. The
module implements very strict type checking, making it virtually
impossible to generate malformed output.

The rest of this section assumes a basic knowledge of Python
(http://python.org).

The 'convert' module contains the function 'output_dataset',
which takes the following arguments:

    1. A Python DataSet object describing a dataset (details to
       follow).

    2. An object with a 'write' method which receives the output
       (e.g. a file object or a StringIO.StringIO object).

The module defines the following Python classes:

    AcceptabilityRatings (ratingsList)
    -----
    Constructor takes a single argument which should be a list of
    strings OR [string, string] pairs (exactly as in a data.js
    file). Note that you must use arrays, not tuples.

    ShuffleSequence (jsCode)
    -----
    Constructor takes a single argument, which should be a string
    containing appropriate JavaScript code (e.g. "rshuffle('foo',
    'bar')").

    Sentence (type, group, words, question=None)
    -----
    'type' and 'group' are self-explanatory. 'words' should be an
    array of strings. 'question' is optional and should be a Question
    object if present.

    Question (question, *answers)
    -----
    'question' should be a string. The remaining arguments give the
    answers the subject can choose from, with the correct answer
    first.

    Dataset (confVars, sentences)
    -----
    'confVars' should be a hashtable giving settings for configuration
    variables in data.js (e.g. 'experimentType'). The values in the
    hashtable must be of a type appropriate to their corresponding
    keys (e.g. the value for the key 'shuffleSequence' must be a
    ShuffleSequence object). There should be no surprises here, but
    check out the definition of the CONF_VARS variable in convert.py
    for a complete specification of permissible types. 'sentences'
    should be an array of Sentence objects.


10. Contact
-----------------------------------------------------------------------
Feel free to contact me with any suggestions or questions at
<a.d.drummond@gmail.com>. It would be great to see people actually
using this, so I'm generally happy to assist with any technical issues
setting up the server, etc.


11. Release notes
-----------------------------------------------------------------------
- ???
Differences between the current version (0.1.3.5) and 0.1.3.4:

    * Now easy to define custom shuffle sequence operators.

    * Raw results file now includes headers like those in the main
      results file.

    * Fixed minor bug in server.py where an exception was not handled
      properly.

- 03 Dec 2007
Differences between 0.1.3.4 and 0.1.3.3:

    * Fixed bad example shuffle sequence in this README.

    * Removed extraneous data.js file accidentally included in
      0.1.3.3 release.

    * Fixed bug which prevented positions of line breaks being
      recorded in results file.

    * Some more detailed documentation for the convert.py module in
      this README.

- 29 Nov 2007
Differences between 0.1.3.3 and 0.1.3.2:

    * Server mode can now be set using the "-m" command line option.

    * Server port can now be set using the "-p" command line option.

    * New 'endsWith' predicate for shuffle sequences.

    * New 'completionMessage' and 'completionErrorMessage'
      configuration variables for data.js.

    * Alert now shown if a shuffle sequence fails to specify any
      sentences.

    * Improved appearance of "sending results to server" message.

- 22 Nov 2007
Differences between 0.1.3.2 and 0.1.3.1:

    * Server's working directory can be set in server_conf.py as as an
      alternative to using an environment variable.

    * convert.py now uses exceptions instead of asserts to signal bad
      data structures.

    * Fixed bug that caused speeded acceptability tasks not to work in
      IE 6.

    * User agent string now included in results headers.

    * Server now uses file locking for results file as well as for
      server state.

    * Important new information in section 8.

- 16 Nov 2007
Differences between 0.1.3.1 and 0.1.3:

    * Fixed bug which caused some shuffle sequences with 'shuffle' to
      send the program into an infinite loop.

    * Shuffle sequences are executed a little more efficiently.

    * "Press space to continue" changed to "Press any key to
      continue."

    * Improved logging of server messages.

    * Working directory of the server process can now be changed by
      setting an environment variable.

    * Added convert.py module to ease automatic generation of data.js
      files.

- 13 Nov 2007
Differences between 0.1.3 and 0.1.3-beta-4:

    * Server now uses file locking for server state on UNIX/Linux/OS
      X.

    * Various improvements to this README.

    * example_data.js included.

- 09 Nov 2007
Differences between the 0.1.3-beta-4 version and 0.1.3-beta-3:

    * Can now be deployed as a CGI process as well as a stand-alone
      server.

    * The server state (i.e. the counter) is now stored on disk in the
      server_state directory.

    * New 'startsWith' and 'not' predicates for shuffle sequences.

    * More detailed documentation in this file.

    * Some improvements in the organization of the JavaScript code
      (addition of dashed_sentence.js).

    * Fixed bug which caused self-paced reading experiments to fail to
      send their results to the server successfully, and speeded
      acceptability experiments to fail to record sentence numbers.

- 03 Nov 2007
Differences between 0.1.3-beta-3 and 0.1.3-beta1/0.1.3-beta2:

    * Fixed bug which prevented newlines from being recorded in
      results (this was introduced in 0.1.3).

- 01 Nov 2007
Differences between 0.1.3beta-1/0.1.3-beta-2 and 0.1.2:

    * Support for latin square designs.

    * Customizable sentence ordering with shuffle sequences (see
      section 5).

    * More configuration options (e.g. showing progress bar is
      optional, instructions are configurable).

    * A number of important bug fixes.
